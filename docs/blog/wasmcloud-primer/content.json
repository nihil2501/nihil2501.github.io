{"is404":false,"staticData":{"1283259357":"[{\"title\":\"Premature Abstraction Is the Root of All Good\",\"slug\":\"premature-abstraction-is-the-root-of-all-good\",\"body\":\"# Premature Abstraction Is the Root of All Good\\n\\n- some evocation of an emperor has no clothes kinda thing.\\n- characterize the imagined points of the bad truism. the (faulty) theory and maybe how it plays out in practice. this is really a key point. what is our hypothesis about the role of this truism—is it really so widely reflected in state-of-the-art software organizations? i kind of think so from experience.\\n- room-cleaning analogy: this is why it is so intuitive—the analogy is not accidental, it is the same Reasoning Process\\n- many citations—grug article? osterhaut?\\n- iterative hypothesizing—forking, joining—always be hypothesizing to some degree—maximally degenerate hypothesis should still denote some non-trivial hypothesis—some form of categorization / boundary.\\n- of course we can only ever be hypothesizing—and we should always be doing it and fundamentally aware that that is what we are doing. so, even though our hypotheses will be wrong, one of the main points of doing this is to make things easier to subtract [prove some version of this idea]. also we are forcing the following Reasoning Process: what was the previous hypothesis? is it now insufficient? the combination of an understanding of the previous hypothesis and a feeling of how it is now insufficient engenders a new hypothesis. our codebases should be environments latent with this—this assisted reasoning process. it should be forcing us to think before we type.\\n- the scary alternative—stochastic non-representation of anything. to drive this home, imagine what this looks like in reality—dev asked to work in some section of code, can not understand what is there because it is not logically possible to understand what is there. this makes life unbearable and that isn’t even an exaggeration.\\n- how the discipline has failed its practitioners with this despicable truism, failing to even state the fundamental nature of the task—encoding / representing concepts. there is no getting around anything. if we are unaware of what we are fundamentally doing, that really is as psychotic, impossible, scary, and wrong as it sounds. it fails the minimum requirements. we really should compare to other engineering disciplines.\\n- maybe i can draw attention to the maybe(not) strange fact that this is always front of mind for me.\\n- what can be done at an organization? the only idea i’ve ever had is education. representing concepts very quickly gets very hard. if not taken seriously, if neglecting to recognize the fundamental nature of the work, we allow the stochastic to take hold, multiply, proliferate. education is one way to take it seriously at an organization. also code reviews. all this needs to be a fundamental pillar of the operation of the organization. how naive is it to back-burner this.\\n- what are the benefits. environments where it is continually possible to proceed successfully. every little thing matters. it’s possible to stay on top of things, and it feels really nice and lets you realize the ideal that software engineering is fun, beautiful, analytical, creative, kind of all of the best things. but yeah, the same things that can make it the best can make it the worse—again the real toll on your mind. and paying attention to this stuff is maybe just the best way to remain as lazy as possible.\\n- the file-level is of prime importance. files should read really well. as soon as it is the case that for some non-trivial percentage of files, opening them makes our eyes bleed, this is a serious existential problem—you will actually be having a bad life.\\n- constant practice\\n- can't process more than one screen of code\\n- context of when you should do this—long lived project\\n- org needs an enforced standard\\n- uninterpretability. having an interpretation of not. some analogy to typed vs untyped?\\n- the discipline unfairly never exposes its practitioners to an elucidation of these fundamental concepts. it is unfairly criminal towards its practitioners.\\n- use invertus as an example?\\n- abstraction specifically can describe all and only what would otherwise necessarily be there in a latent or implicit form. it does not need to be something that necessarily describes more than what is already there.\\n- principal conceit: whether or not we perceive it, our software possesses a property that is its degree of interpretability. the functioning of our software and the functioning of our development of our software is a function of its degree of interpretability. let more of us in the discipline begin to perceive this and act on our perception of it.\\n- code that is not attempting to describe concepts\\n- for this to be an afterthought is like replacing your codebase with compiler output\\n- Abstraction Driven Development\"},{\"title\":\"wasmCloud Primer\",\"slug\":\"wasmcloud-primer\",\"body\":\"# wasmCloud Primer\\n\\n- versus wasi\\n- versus serverless\\n- single point of failure?\\n- nats guarantees?\\n- cross-cloud substrate given by component model? or is that a feature of this platform designed around nats?\\n- “””service chaining without the intervening network stack””” —[from keynote [on parametric linking](https://youtu.be/phodPLY8zNE?t=397)\\n- “””application layer interfaces that avoid sidecar protocol parsing overhead””” —[from keynote [on resources and handles]](https://youtu.be/phodPLY8zNE?t=660)\\n- does wasmcloud moreso fit a distributed computing platform layer alluded to —[keynote](https://youtu.be/phodPLY8zNE?t=883)\\n- explain (to self) how fundamentally different this is from current cloud —[keynote [on virtualization]](https://youtu.be/phodPLY8zNE?t=1401)\\n\\n![Screen Shot 2022-12-20 at 10.32.50 PM.png](wasmCloud%20Primer%20752de0c667b842ad9f5b4db0ff06695c/Screen_Shot_2022-12-20_at_10.32.50_PM.png)\"}]"},"path":"blog/wasmcloud-primer"}